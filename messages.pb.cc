// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: messages.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "messages.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace yosysZKP {

namespace {

const ::google::protobuf::Descriptor* WireValues_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  WireValues_reflection_ = NULL;
const ::google::protobuf::Descriptor* TruthTableEntry_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  TruthTableEntry_reflection_ = NULL;
const ::google::protobuf::Descriptor* TruthTable_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  TruthTable_reflection_ = NULL;
const ::google::protobuf::Descriptor* TableCommitment_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  TableCommitment_reflection_ = NULL;
const ::google::protobuf::Descriptor* Commitment_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Commitment_reflection_ = NULL;
const ::google::protobuf::Descriptor* ExecutionReveal_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ExecutionReveal_reflection_ = NULL;
const ::google::protobuf::Descriptor* ScramblingReveal_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ScramblingReveal_reflection_ = NULL;
const ::google::protobuf::Descriptor* ProverSecret_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ProverSecret_reflection_ = NULL;
const ::google::protobuf::Descriptor* RevealRequest_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  RevealRequest_reflection_ = NULL;
const ::google::protobuf::Descriptor* ProveeState_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ProveeState_reflection_ = NULL;

}  // namespace


void protobuf_AssignDesc_messages_2eproto() {
  protobuf_AddDesc_messages_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "messages.proto");
  GOOGLE_CHECK(file != NULL);
  WireValues_descriptor_ = file->message_type(0);
  static const int WireValues_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WireValues, entries_),
  };
  WireValues_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      WireValues_descriptor_,
      WireValues::default_instance_,
      WireValues_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WireValues, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WireValues, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(WireValues));
  TruthTableEntry_descriptor_ = file->message_type(1);
  static const int TruthTableEntry_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TruthTableEntry, inputs_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TruthTableEntry, outputs_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TruthTableEntry, nonce_),
  };
  TruthTableEntry_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      TruthTableEntry_descriptor_,
      TruthTableEntry::default_instance_,
      TruthTableEntry_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TruthTableEntry, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TruthTableEntry, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(TruthTableEntry));
  TruthTable_descriptor_ = file->message_type(2);
  static const int TruthTable_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TruthTable, entries_),
  };
  TruthTable_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      TruthTable_descriptor_,
      TruthTable::default_instance_,
      TruthTable_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TruthTable, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TruthTable, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(TruthTable));
  TableCommitment_descriptor_ = file->message_type(3);
  static const int TableCommitment_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TableCommitment, entryhashes_),
  };
  TableCommitment_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      TableCommitment_descriptor_,
      TableCommitment::default_instance_,
      TableCommitment_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TableCommitment, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TableCommitment, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(TableCommitment));
  Commitment_descriptor_ = file->message_type(4);
  static const int Commitment_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Commitment, output_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Commitment, gatehashes_),
  };
  Commitment_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Commitment_descriptor_,
      Commitment::default_instance_,
      Commitment_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Commitment, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Commitment, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Commitment));
  ExecutionReveal_descriptor_ = file->message_type(5);
  static const int ExecutionReveal_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ExecutionReveal, exec_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ExecutionReveal, entries_),
  };
  ExecutionReveal_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ExecutionReveal_descriptor_,
      ExecutionReveal::default_instance_,
      ExecutionReveal_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ExecutionReveal, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ExecutionReveal, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ExecutionReveal));
  ScramblingReveal_descriptor_ = file->message_type(6);
  static const int ScramblingReveal_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ScramblingReveal, keys_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ScramblingReveal, gates_),
  };
  ScramblingReveal_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ScramblingReveal_descriptor_,
      ScramblingReveal::default_instance_,
      ScramblingReveal_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ScramblingReveal, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ScramblingReveal, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ScramblingReveal));
  ProverSecret_descriptor_ = file->message_type(7);
  static const int ProverSecret_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ProverSecret, execution_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ProverSecret, scrambling_),
  };
  ProverSecret_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ProverSecret_descriptor_,
      ProverSecret::default_instance_,
      ProverSecret_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ProverSecret, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ProverSecret, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ProverSecret));
  RevealRequest_descriptor_ = file->message_type(8);
  static const int RevealRequest_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RevealRequest, scrambling_),
  };
  RevealRequest_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      RevealRequest_descriptor_,
      RevealRequest::default_instance_,
      RevealRequest_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RevealRequest, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RevealRequest, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(RevealRequest));
  ProveeState_descriptor_ = file->message_type(9);
  static const int ProveeState_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ProveeState, scrambling_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ProveeState, commitment_),
  };
  ProveeState_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ProveeState_descriptor_,
      ProveeState::default_instance_,
      ProveeState_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ProveeState, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ProveeState, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ProveeState));
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_messages_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    WireValues_descriptor_, &WireValues::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    TruthTableEntry_descriptor_, &TruthTableEntry::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    TruthTable_descriptor_, &TruthTable::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    TableCommitment_descriptor_, &TableCommitment::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Commitment_descriptor_, &Commitment::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ExecutionReveal_descriptor_, &ExecutionReveal::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ScramblingReveal_descriptor_, &ScramblingReveal::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ProverSecret_descriptor_, &ProverSecret::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    RevealRequest_descriptor_, &RevealRequest::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ProveeState_descriptor_, &ProveeState::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_messages_2eproto() {
  delete WireValues::default_instance_;
  delete WireValues_reflection_;
  delete TruthTableEntry::default_instance_;
  delete TruthTableEntry_reflection_;
  delete TruthTable::default_instance_;
  delete TruthTable_reflection_;
  delete TableCommitment::default_instance_;
  delete TableCommitment_reflection_;
  delete Commitment::default_instance_;
  delete Commitment_reflection_;
  delete ExecutionReveal::default_instance_;
  delete ExecutionReveal_reflection_;
  delete ScramblingReveal::default_instance_;
  delete ScramblingReveal_reflection_;
  delete ProverSecret::default_instance_;
  delete ProverSecret_reflection_;
  delete RevealRequest::default_instance_;
  delete RevealRequest_reflection_;
  delete ProveeState::default_instance_;
  delete ProveeState_reflection_;
}

void protobuf_AddDesc_messages_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\016messages.proto\022\010yosysZKP\"\035\n\nWireValues"
    "\022\017\n\007entries\030\001 \003(\010\"A\n\017TruthTableEntry\022\016\n\006"
    "inputs\030\001 \003(\010\022\017\n\007outputs\030\002 \003(\010\022\r\n\005nonce\030\003"
    " \002(\014\"8\n\nTruthTable\022*\n\007entries\030\001 \003(\0132\031.yo"
    "sysZKP.TruthTableEntry\"&\n\017TableCommitmen"
    "t\022\023\n\013entryhashes\030\001 \003(\014\"K\n\nCommitment\022\016\n\006"
    "output\030\001 \003(\010\022-\n\ngatehashes\030\002 \003(\0132\031.yosys"
    "ZKP.TableCommitment\"a\n\017ExecutionReveal\022\""
    "\n\004exec\030\001 \002(\0132\024.yosysZKP.WireValues\022*\n\007en"
    "tries\030\002 \003(\0132\031.yosysZKP.TruthTableEntry\"["
    "\n\020ScramblingReveal\022\"\n\004keys\030\001 \002(\0132\024.yosys"
    "ZKP.WireValues\022#\n\005gates\030\002 \003(\0132\024.yosysZKP"
    ".TruthTable\"l\n\014ProverSecret\022,\n\texecution"
    "\030\001 \001(\0132\031.yosysZKP.ExecutionReveal\022.\n\nscr"
    "ambling\030\002 \001(\0132\032.yosysZKP.ScramblingRevea"
    "l\"#\n\rRevealRequest\022\022\n\nscrambling\030\001 \003(\010\"K"
    "\n\013ProveeState\022\022\n\nscrambling\030\001 \002(\010\022(\n\ncom"
    "mitment\030\002 \002(\0132\024.yosysZKP.Commitment", 715);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "messages.proto", &protobuf_RegisterTypes);
  WireValues::default_instance_ = new WireValues();
  TruthTableEntry::default_instance_ = new TruthTableEntry();
  TruthTable::default_instance_ = new TruthTable();
  TableCommitment::default_instance_ = new TableCommitment();
  Commitment::default_instance_ = new Commitment();
  ExecutionReveal::default_instance_ = new ExecutionReveal();
  ScramblingReveal::default_instance_ = new ScramblingReveal();
  ProverSecret::default_instance_ = new ProverSecret();
  RevealRequest::default_instance_ = new RevealRequest();
  ProveeState::default_instance_ = new ProveeState();
  WireValues::default_instance_->InitAsDefaultInstance();
  TruthTableEntry::default_instance_->InitAsDefaultInstance();
  TruthTable::default_instance_->InitAsDefaultInstance();
  TableCommitment::default_instance_->InitAsDefaultInstance();
  Commitment::default_instance_->InitAsDefaultInstance();
  ExecutionReveal::default_instance_->InitAsDefaultInstance();
  ScramblingReveal::default_instance_->InitAsDefaultInstance();
  ProverSecret::default_instance_->InitAsDefaultInstance();
  RevealRequest::default_instance_->InitAsDefaultInstance();
  ProveeState::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_messages_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_messages_2eproto {
  StaticDescriptorInitializer_messages_2eproto() {
    protobuf_AddDesc_messages_2eproto();
  }
} static_descriptor_initializer_messages_2eproto_;

// ===================================================================

#ifndef _MSC_VER
const int WireValues::kEntriesFieldNumber;
#endif  // !_MSC_VER

WireValues::WireValues()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:yosysZKP.WireValues)
}

void WireValues::InitAsDefaultInstance() {
}

WireValues::WireValues(const WireValues& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:yosysZKP.WireValues)
}

void WireValues::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

WireValues::~WireValues() {
  // @@protoc_insertion_point(destructor:yosysZKP.WireValues)
  SharedDtor();
}

void WireValues::SharedDtor() {
  if (this != default_instance_) {
  }
}

void WireValues::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* WireValues::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return WireValues_descriptor_;
}

const WireValues& WireValues::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();
  return *default_instance_;
}

WireValues* WireValues::default_instance_ = NULL;

WireValues* WireValues::New() const {
  return new WireValues;
}

void WireValues::Clear() {
  entries_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool WireValues::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:yosysZKP.WireValues)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated bool entries = 1;
      case 1: {
        if (tag == 8) {
         parse_entries:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 1, 8, input, this->mutable_entries())));
        } else if (tag == 10) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, this->mutable_entries())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(8)) goto parse_entries;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:yosysZKP.WireValues)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:yosysZKP.WireValues)
  return false;
#undef DO_
}

void WireValues::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:yosysZKP.WireValues)
  // repeated bool entries = 1;
  for (int i = 0; i < this->entries_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(
      1, this->entries(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:yosysZKP.WireValues)
}

::google::protobuf::uint8* WireValues::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:yosysZKP.WireValues)
  // repeated bool entries = 1;
  for (int i = 0; i < this->entries_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteBoolToArray(1, this->entries(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:yosysZKP.WireValues)
  return target;
}

int WireValues::ByteSize() const {
  int total_size = 0;

  // repeated bool entries = 1;
  {
    int data_size = 0;
    data_size = 1 * this->entries_size();
    total_size += 1 * this->entries_size() + data_size;
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void WireValues::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const WireValues* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const WireValues*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void WireValues::MergeFrom(const WireValues& from) {
  GOOGLE_CHECK_NE(&from, this);
  entries_.MergeFrom(from.entries_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void WireValues::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void WireValues::CopyFrom(const WireValues& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool WireValues::IsInitialized() const {

  return true;
}

void WireValues::Swap(WireValues* other) {
  if (other != this) {
    entries_.Swap(&other->entries_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata WireValues::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = WireValues_descriptor_;
  metadata.reflection = WireValues_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int TruthTableEntry::kInputsFieldNumber;
const int TruthTableEntry::kOutputsFieldNumber;
const int TruthTableEntry::kNonceFieldNumber;
#endif  // !_MSC_VER

TruthTableEntry::TruthTableEntry()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:yosysZKP.TruthTableEntry)
}

void TruthTableEntry::InitAsDefaultInstance() {
}

TruthTableEntry::TruthTableEntry(const TruthTableEntry& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:yosysZKP.TruthTableEntry)
}

void TruthTableEntry::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  nonce_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TruthTableEntry::~TruthTableEntry() {
  // @@protoc_insertion_point(destructor:yosysZKP.TruthTableEntry)
  SharedDtor();
}

void TruthTableEntry::SharedDtor() {
  if (nonce_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete nonce_;
  }
  if (this != default_instance_) {
  }
}

void TruthTableEntry::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* TruthTableEntry::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TruthTableEntry_descriptor_;
}

const TruthTableEntry& TruthTableEntry::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();
  return *default_instance_;
}

TruthTableEntry* TruthTableEntry::default_instance_ = NULL;

TruthTableEntry* TruthTableEntry::New() const {
  return new TruthTableEntry;
}

void TruthTableEntry::Clear() {
  if (has_nonce()) {
    if (nonce_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
      nonce_->clear();
    }
  }
  inputs_.Clear();
  outputs_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool TruthTableEntry::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:yosysZKP.TruthTableEntry)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated bool inputs = 1;
      case 1: {
        if (tag == 8) {
         parse_inputs:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 1, 8, input, this->mutable_inputs())));
        } else if (tag == 10) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, this->mutable_inputs())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(8)) goto parse_inputs;
        if (input->ExpectTag(16)) goto parse_outputs;
        break;
      }

      // repeated bool outputs = 2;
      case 2: {
        if (tag == 16) {
         parse_outputs:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 1, 16, input, this->mutable_outputs())));
        } else if (tag == 18) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, this->mutable_outputs())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_outputs;
        if (input->ExpectTag(26)) goto parse_nonce;
        break;
      }

      // required bytes nonce = 3;
      case 3: {
        if (tag == 26) {
         parse_nonce:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_nonce()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:yosysZKP.TruthTableEntry)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:yosysZKP.TruthTableEntry)
  return false;
#undef DO_
}

void TruthTableEntry::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:yosysZKP.TruthTableEntry)
  // repeated bool inputs = 1;
  for (int i = 0; i < this->inputs_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(
      1, this->inputs(i), output);
  }

  // repeated bool outputs = 2;
  for (int i = 0; i < this->outputs_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(
      2, this->outputs(i), output);
  }

  // required bytes nonce = 3;
  if (has_nonce()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      3, this->nonce(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:yosysZKP.TruthTableEntry)
}

::google::protobuf::uint8* TruthTableEntry::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:yosysZKP.TruthTableEntry)
  // repeated bool inputs = 1;
  for (int i = 0; i < this->inputs_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteBoolToArray(1, this->inputs(i), target);
  }

  // repeated bool outputs = 2;
  for (int i = 0; i < this->outputs_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteBoolToArray(2, this->outputs(i), target);
  }

  // required bytes nonce = 3;
  if (has_nonce()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        3, this->nonce(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:yosysZKP.TruthTableEntry)
  return target;
}

int TruthTableEntry::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[2 / 32] & (0xffu << (2 % 32))) {
    // required bytes nonce = 3;
    if (has_nonce()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->nonce());
    }

  }
  // repeated bool inputs = 1;
  {
    int data_size = 0;
    data_size = 1 * this->inputs_size();
    total_size += 1 * this->inputs_size() + data_size;
  }

  // repeated bool outputs = 2;
  {
    int data_size = 0;
    data_size = 1 * this->outputs_size();
    total_size += 1 * this->outputs_size() + data_size;
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TruthTableEntry::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const TruthTableEntry* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const TruthTableEntry*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void TruthTableEntry::MergeFrom(const TruthTableEntry& from) {
  GOOGLE_CHECK_NE(&from, this);
  inputs_.MergeFrom(from.inputs_);
  outputs_.MergeFrom(from.outputs_);
  if (from._has_bits_[2 / 32] & (0xffu << (2 % 32))) {
    if (from.has_nonce()) {
      set_nonce(from.nonce());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void TruthTableEntry::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TruthTableEntry::CopyFrom(const TruthTableEntry& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TruthTableEntry::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000004) != 0x00000004) return false;

  return true;
}

void TruthTableEntry::Swap(TruthTableEntry* other) {
  if (other != this) {
    inputs_.Swap(&other->inputs_);
    outputs_.Swap(&other->outputs_);
    std::swap(nonce_, other->nonce_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata TruthTableEntry::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = TruthTableEntry_descriptor_;
  metadata.reflection = TruthTableEntry_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int TruthTable::kEntriesFieldNumber;
#endif  // !_MSC_VER

TruthTable::TruthTable()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:yosysZKP.TruthTable)
}

void TruthTable::InitAsDefaultInstance() {
}

TruthTable::TruthTable(const TruthTable& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:yosysZKP.TruthTable)
}

void TruthTable::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TruthTable::~TruthTable() {
  // @@protoc_insertion_point(destructor:yosysZKP.TruthTable)
  SharedDtor();
}

void TruthTable::SharedDtor() {
  if (this != default_instance_) {
  }
}

void TruthTable::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* TruthTable::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TruthTable_descriptor_;
}

const TruthTable& TruthTable::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();
  return *default_instance_;
}

TruthTable* TruthTable::default_instance_ = NULL;

TruthTable* TruthTable::New() const {
  return new TruthTable;
}

void TruthTable::Clear() {
  entries_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool TruthTable::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:yosysZKP.TruthTable)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .yosysZKP.TruthTableEntry entries = 1;
      case 1: {
        if (tag == 10) {
         parse_entries:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_entries()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_entries;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:yosysZKP.TruthTable)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:yosysZKP.TruthTable)
  return false;
#undef DO_
}

void TruthTable::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:yosysZKP.TruthTable)
  // repeated .yosysZKP.TruthTableEntry entries = 1;
  for (int i = 0; i < this->entries_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->entries(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:yosysZKP.TruthTable)
}

::google::protobuf::uint8* TruthTable::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:yosysZKP.TruthTable)
  // repeated .yosysZKP.TruthTableEntry entries = 1;
  for (int i = 0; i < this->entries_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->entries(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:yosysZKP.TruthTable)
  return target;
}

int TruthTable::ByteSize() const {
  int total_size = 0;

  // repeated .yosysZKP.TruthTableEntry entries = 1;
  total_size += 1 * this->entries_size();
  for (int i = 0; i < this->entries_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->entries(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TruthTable::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const TruthTable* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const TruthTable*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void TruthTable::MergeFrom(const TruthTable& from) {
  GOOGLE_CHECK_NE(&from, this);
  entries_.MergeFrom(from.entries_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void TruthTable::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TruthTable::CopyFrom(const TruthTable& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TruthTable::IsInitialized() const {

  if (!::google::protobuf::internal::AllAreInitialized(this->entries())) return false;
  return true;
}

void TruthTable::Swap(TruthTable* other) {
  if (other != this) {
    entries_.Swap(&other->entries_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata TruthTable::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = TruthTable_descriptor_;
  metadata.reflection = TruthTable_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int TableCommitment::kEntryhashesFieldNumber;
#endif  // !_MSC_VER

TableCommitment::TableCommitment()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:yosysZKP.TableCommitment)
}

void TableCommitment::InitAsDefaultInstance() {
}

TableCommitment::TableCommitment(const TableCommitment& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:yosysZKP.TableCommitment)
}

void TableCommitment::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TableCommitment::~TableCommitment() {
  // @@protoc_insertion_point(destructor:yosysZKP.TableCommitment)
  SharedDtor();
}

void TableCommitment::SharedDtor() {
  if (this != default_instance_) {
  }
}

void TableCommitment::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* TableCommitment::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TableCommitment_descriptor_;
}

const TableCommitment& TableCommitment::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();
  return *default_instance_;
}

TableCommitment* TableCommitment::default_instance_ = NULL;

TableCommitment* TableCommitment::New() const {
  return new TableCommitment;
}

void TableCommitment::Clear() {
  entryhashes_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool TableCommitment::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:yosysZKP.TableCommitment)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated bytes entryhashes = 1;
      case 1: {
        if (tag == 10) {
         parse_entryhashes:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->add_entryhashes()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_entryhashes;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:yosysZKP.TableCommitment)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:yosysZKP.TableCommitment)
  return false;
#undef DO_
}

void TableCommitment::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:yosysZKP.TableCommitment)
  // repeated bytes entryhashes = 1;
  for (int i = 0; i < this->entryhashes_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      1, this->entryhashes(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:yosysZKP.TableCommitment)
}

::google::protobuf::uint8* TableCommitment::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:yosysZKP.TableCommitment)
  // repeated bytes entryhashes = 1;
  for (int i = 0; i < this->entryhashes_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteBytesToArray(1, this->entryhashes(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:yosysZKP.TableCommitment)
  return target;
}

int TableCommitment::ByteSize() const {
  int total_size = 0;

  // repeated bytes entryhashes = 1;
  total_size += 1 * this->entryhashes_size();
  for (int i = 0; i < this->entryhashes_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::BytesSize(
      this->entryhashes(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TableCommitment::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const TableCommitment* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const TableCommitment*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void TableCommitment::MergeFrom(const TableCommitment& from) {
  GOOGLE_CHECK_NE(&from, this);
  entryhashes_.MergeFrom(from.entryhashes_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void TableCommitment::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TableCommitment::CopyFrom(const TableCommitment& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TableCommitment::IsInitialized() const {

  return true;
}

void TableCommitment::Swap(TableCommitment* other) {
  if (other != this) {
    entryhashes_.Swap(&other->entryhashes_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata TableCommitment::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = TableCommitment_descriptor_;
  metadata.reflection = TableCommitment_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Commitment::kOutputFieldNumber;
const int Commitment::kGatehashesFieldNumber;
#endif  // !_MSC_VER

Commitment::Commitment()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:yosysZKP.Commitment)
}

void Commitment::InitAsDefaultInstance() {
}

Commitment::Commitment(const Commitment& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:yosysZKP.Commitment)
}

void Commitment::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Commitment::~Commitment() {
  // @@protoc_insertion_point(destructor:yosysZKP.Commitment)
  SharedDtor();
}

void Commitment::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Commitment::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Commitment::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Commitment_descriptor_;
}

const Commitment& Commitment::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();
  return *default_instance_;
}

Commitment* Commitment::default_instance_ = NULL;

Commitment* Commitment::New() const {
  return new Commitment;
}

void Commitment::Clear() {
  output_.Clear();
  gatehashes_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Commitment::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:yosysZKP.Commitment)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated bool output = 1;
      case 1: {
        if (tag == 8) {
         parse_output:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 1, 8, input, this->mutable_output())));
        } else if (tag == 10) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, this->mutable_output())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(8)) goto parse_output;
        if (input->ExpectTag(18)) goto parse_gatehashes;
        break;
      }

      // repeated .yosysZKP.TableCommitment gatehashes = 2;
      case 2: {
        if (tag == 18) {
         parse_gatehashes:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_gatehashes()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_gatehashes;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:yosysZKP.Commitment)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:yosysZKP.Commitment)
  return false;
#undef DO_
}

void Commitment::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:yosysZKP.Commitment)
  // repeated bool output = 1;
  for (int i = 0; i < this->output_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(
      1, this->output(i), output);
  }

  // repeated .yosysZKP.TableCommitment gatehashes = 2;
  for (int i = 0; i < this->gatehashes_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->gatehashes(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:yosysZKP.Commitment)
}

::google::protobuf::uint8* Commitment::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:yosysZKP.Commitment)
  // repeated bool output = 1;
  for (int i = 0; i < this->output_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteBoolToArray(1, this->output(i), target);
  }

  // repeated .yosysZKP.TableCommitment gatehashes = 2;
  for (int i = 0; i < this->gatehashes_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->gatehashes(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:yosysZKP.Commitment)
  return target;
}

int Commitment::ByteSize() const {
  int total_size = 0;

  // repeated bool output = 1;
  {
    int data_size = 0;
    data_size = 1 * this->output_size();
    total_size += 1 * this->output_size() + data_size;
  }

  // repeated .yosysZKP.TableCommitment gatehashes = 2;
  total_size += 1 * this->gatehashes_size();
  for (int i = 0; i < this->gatehashes_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->gatehashes(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Commitment::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Commitment* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Commitment*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Commitment::MergeFrom(const Commitment& from) {
  GOOGLE_CHECK_NE(&from, this);
  output_.MergeFrom(from.output_);
  gatehashes_.MergeFrom(from.gatehashes_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Commitment::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Commitment::CopyFrom(const Commitment& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Commitment::IsInitialized() const {

  return true;
}

void Commitment::Swap(Commitment* other) {
  if (other != this) {
    output_.Swap(&other->output_);
    gatehashes_.Swap(&other->gatehashes_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Commitment::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Commitment_descriptor_;
  metadata.reflection = Commitment_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ExecutionReveal::kExecFieldNumber;
const int ExecutionReveal::kEntriesFieldNumber;
#endif  // !_MSC_VER

ExecutionReveal::ExecutionReveal()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:yosysZKP.ExecutionReveal)
}

void ExecutionReveal::InitAsDefaultInstance() {
  exec_ = const_cast< ::yosysZKP::WireValues*>(&::yosysZKP::WireValues::default_instance());
}

ExecutionReveal::ExecutionReveal(const ExecutionReveal& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:yosysZKP.ExecutionReveal)
}

void ExecutionReveal::SharedCtor() {
  _cached_size_ = 0;
  exec_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ExecutionReveal::~ExecutionReveal() {
  // @@protoc_insertion_point(destructor:yosysZKP.ExecutionReveal)
  SharedDtor();
}

void ExecutionReveal::SharedDtor() {
  if (this != default_instance_) {
    delete exec_;
  }
}

void ExecutionReveal::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ExecutionReveal::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ExecutionReveal_descriptor_;
}

const ExecutionReveal& ExecutionReveal::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();
  return *default_instance_;
}

ExecutionReveal* ExecutionReveal::default_instance_ = NULL;

ExecutionReveal* ExecutionReveal::New() const {
  return new ExecutionReveal;
}

void ExecutionReveal::Clear() {
  if (has_exec()) {
    if (exec_ != NULL) exec_->::yosysZKP::WireValues::Clear();
  }
  entries_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ExecutionReveal::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:yosysZKP.ExecutionReveal)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .yosysZKP.WireValues exec = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_exec()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_entries;
        break;
      }

      // repeated .yosysZKP.TruthTableEntry entries = 2;
      case 2: {
        if (tag == 18) {
         parse_entries:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_entries()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_entries;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:yosysZKP.ExecutionReveal)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:yosysZKP.ExecutionReveal)
  return false;
#undef DO_
}

void ExecutionReveal::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:yosysZKP.ExecutionReveal)
  // required .yosysZKP.WireValues exec = 1;
  if (has_exec()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->exec(), output);
  }

  // repeated .yosysZKP.TruthTableEntry entries = 2;
  for (int i = 0; i < this->entries_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->entries(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:yosysZKP.ExecutionReveal)
}

::google::protobuf::uint8* ExecutionReveal::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:yosysZKP.ExecutionReveal)
  // required .yosysZKP.WireValues exec = 1;
  if (has_exec()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->exec(), target);
  }

  // repeated .yosysZKP.TruthTableEntry entries = 2;
  for (int i = 0; i < this->entries_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->entries(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:yosysZKP.ExecutionReveal)
  return target;
}

int ExecutionReveal::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .yosysZKP.WireValues exec = 1;
    if (has_exec()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->exec());
    }

  }
  // repeated .yosysZKP.TruthTableEntry entries = 2;
  total_size += 1 * this->entries_size();
  for (int i = 0; i < this->entries_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->entries(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ExecutionReveal::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ExecutionReveal* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ExecutionReveal*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ExecutionReveal::MergeFrom(const ExecutionReveal& from) {
  GOOGLE_CHECK_NE(&from, this);
  entries_.MergeFrom(from.entries_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_exec()) {
      mutable_exec()->::yosysZKP::WireValues::MergeFrom(from.exec());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ExecutionReveal::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ExecutionReveal::CopyFrom(const ExecutionReveal& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ExecutionReveal::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (!::google::protobuf::internal::AllAreInitialized(this->entries())) return false;
  return true;
}

void ExecutionReveal::Swap(ExecutionReveal* other) {
  if (other != this) {
    std::swap(exec_, other->exec_);
    entries_.Swap(&other->entries_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ExecutionReveal::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ExecutionReveal_descriptor_;
  metadata.reflection = ExecutionReveal_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ScramblingReveal::kKeysFieldNumber;
const int ScramblingReveal::kGatesFieldNumber;
#endif  // !_MSC_VER

ScramblingReveal::ScramblingReveal()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:yosysZKP.ScramblingReveal)
}

void ScramblingReveal::InitAsDefaultInstance() {
  keys_ = const_cast< ::yosysZKP::WireValues*>(&::yosysZKP::WireValues::default_instance());
}

ScramblingReveal::ScramblingReveal(const ScramblingReveal& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:yosysZKP.ScramblingReveal)
}

void ScramblingReveal::SharedCtor() {
  _cached_size_ = 0;
  keys_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ScramblingReveal::~ScramblingReveal() {
  // @@protoc_insertion_point(destructor:yosysZKP.ScramblingReveal)
  SharedDtor();
}

void ScramblingReveal::SharedDtor() {
  if (this != default_instance_) {
    delete keys_;
  }
}

void ScramblingReveal::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ScramblingReveal::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ScramblingReveal_descriptor_;
}

const ScramblingReveal& ScramblingReveal::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();
  return *default_instance_;
}

ScramblingReveal* ScramblingReveal::default_instance_ = NULL;

ScramblingReveal* ScramblingReveal::New() const {
  return new ScramblingReveal;
}

void ScramblingReveal::Clear() {
  if (has_keys()) {
    if (keys_ != NULL) keys_->::yosysZKP::WireValues::Clear();
  }
  gates_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ScramblingReveal::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:yosysZKP.ScramblingReveal)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .yosysZKP.WireValues keys = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_keys()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_gates;
        break;
      }

      // repeated .yosysZKP.TruthTable gates = 2;
      case 2: {
        if (tag == 18) {
         parse_gates:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_gates()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_gates;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:yosysZKP.ScramblingReveal)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:yosysZKP.ScramblingReveal)
  return false;
#undef DO_
}

void ScramblingReveal::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:yosysZKP.ScramblingReveal)
  // required .yosysZKP.WireValues keys = 1;
  if (has_keys()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->keys(), output);
  }

  // repeated .yosysZKP.TruthTable gates = 2;
  for (int i = 0; i < this->gates_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->gates(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:yosysZKP.ScramblingReveal)
}

::google::protobuf::uint8* ScramblingReveal::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:yosysZKP.ScramblingReveal)
  // required .yosysZKP.WireValues keys = 1;
  if (has_keys()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->keys(), target);
  }

  // repeated .yosysZKP.TruthTable gates = 2;
  for (int i = 0; i < this->gates_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->gates(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:yosysZKP.ScramblingReveal)
  return target;
}

int ScramblingReveal::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .yosysZKP.WireValues keys = 1;
    if (has_keys()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->keys());
    }

  }
  // repeated .yosysZKP.TruthTable gates = 2;
  total_size += 1 * this->gates_size();
  for (int i = 0; i < this->gates_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->gates(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ScramblingReveal::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ScramblingReveal* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ScramblingReveal*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ScramblingReveal::MergeFrom(const ScramblingReveal& from) {
  GOOGLE_CHECK_NE(&from, this);
  gates_.MergeFrom(from.gates_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_keys()) {
      mutable_keys()->::yosysZKP::WireValues::MergeFrom(from.keys());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ScramblingReveal::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ScramblingReveal::CopyFrom(const ScramblingReveal& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ScramblingReveal::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (!::google::protobuf::internal::AllAreInitialized(this->gates())) return false;
  return true;
}

void ScramblingReveal::Swap(ScramblingReveal* other) {
  if (other != this) {
    std::swap(keys_, other->keys_);
    gates_.Swap(&other->gates_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ScramblingReveal::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ScramblingReveal_descriptor_;
  metadata.reflection = ScramblingReveal_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ProverSecret::kExecutionFieldNumber;
const int ProverSecret::kScramblingFieldNumber;
#endif  // !_MSC_VER

ProverSecret::ProverSecret()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:yosysZKP.ProverSecret)
}

void ProverSecret::InitAsDefaultInstance() {
  execution_ = const_cast< ::yosysZKP::ExecutionReveal*>(&::yosysZKP::ExecutionReveal::default_instance());
  scrambling_ = const_cast< ::yosysZKP::ScramblingReveal*>(&::yosysZKP::ScramblingReveal::default_instance());
}

ProverSecret::ProverSecret(const ProverSecret& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:yosysZKP.ProverSecret)
}

void ProverSecret::SharedCtor() {
  _cached_size_ = 0;
  execution_ = NULL;
  scrambling_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ProverSecret::~ProverSecret() {
  // @@protoc_insertion_point(destructor:yosysZKP.ProverSecret)
  SharedDtor();
}

void ProverSecret::SharedDtor() {
  if (this != default_instance_) {
    delete execution_;
    delete scrambling_;
  }
}

void ProverSecret::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ProverSecret::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ProverSecret_descriptor_;
}

const ProverSecret& ProverSecret::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();
  return *default_instance_;
}

ProverSecret* ProverSecret::default_instance_ = NULL;

ProverSecret* ProverSecret::New() const {
  return new ProverSecret;
}

void ProverSecret::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    if (has_execution()) {
      if (execution_ != NULL) execution_->::yosysZKP::ExecutionReveal::Clear();
    }
    if (has_scrambling()) {
      if (scrambling_ != NULL) scrambling_->::yosysZKP::ScramblingReveal::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ProverSecret::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:yosysZKP.ProverSecret)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .yosysZKP.ExecutionReveal execution = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_execution()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_scrambling;
        break;
      }

      // optional .yosysZKP.ScramblingReveal scrambling = 2;
      case 2: {
        if (tag == 18) {
         parse_scrambling:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_scrambling()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:yosysZKP.ProverSecret)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:yosysZKP.ProverSecret)
  return false;
#undef DO_
}

void ProverSecret::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:yosysZKP.ProverSecret)
  // optional .yosysZKP.ExecutionReveal execution = 1;
  if (has_execution()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->execution(), output);
  }

  // optional .yosysZKP.ScramblingReveal scrambling = 2;
  if (has_scrambling()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->scrambling(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:yosysZKP.ProverSecret)
}

::google::protobuf::uint8* ProverSecret::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:yosysZKP.ProverSecret)
  // optional .yosysZKP.ExecutionReveal execution = 1;
  if (has_execution()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->execution(), target);
  }

  // optional .yosysZKP.ScramblingReveal scrambling = 2;
  if (has_scrambling()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->scrambling(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:yosysZKP.ProverSecret)
  return target;
}

int ProverSecret::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .yosysZKP.ExecutionReveal execution = 1;
    if (has_execution()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->execution());
    }

    // optional .yosysZKP.ScramblingReveal scrambling = 2;
    if (has_scrambling()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->scrambling());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ProverSecret::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ProverSecret* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ProverSecret*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ProverSecret::MergeFrom(const ProverSecret& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_execution()) {
      mutable_execution()->::yosysZKP::ExecutionReveal::MergeFrom(from.execution());
    }
    if (from.has_scrambling()) {
      mutable_scrambling()->::yosysZKP::ScramblingReveal::MergeFrom(from.scrambling());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ProverSecret::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ProverSecret::CopyFrom(const ProverSecret& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ProverSecret::IsInitialized() const {

  if (has_execution()) {
    if (!this->execution().IsInitialized()) return false;
  }
  if (has_scrambling()) {
    if (!this->scrambling().IsInitialized()) return false;
  }
  return true;
}

void ProverSecret::Swap(ProverSecret* other) {
  if (other != this) {
    std::swap(execution_, other->execution_);
    std::swap(scrambling_, other->scrambling_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ProverSecret::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ProverSecret_descriptor_;
  metadata.reflection = ProverSecret_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int RevealRequest::kScramblingFieldNumber;
#endif  // !_MSC_VER

RevealRequest::RevealRequest()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:yosysZKP.RevealRequest)
}

void RevealRequest::InitAsDefaultInstance() {
}

RevealRequest::RevealRequest(const RevealRequest& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:yosysZKP.RevealRequest)
}

void RevealRequest::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RevealRequest::~RevealRequest() {
  // @@protoc_insertion_point(destructor:yosysZKP.RevealRequest)
  SharedDtor();
}

void RevealRequest::SharedDtor() {
  if (this != default_instance_) {
  }
}

void RevealRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* RevealRequest::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return RevealRequest_descriptor_;
}

const RevealRequest& RevealRequest::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();
  return *default_instance_;
}

RevealRequest* RevealRequest::default_instance_ = NULL;

RevealRequest* RevealRequest::New() const {
  return new RevealRequest;
}

void RevealRequest::Clear() {
  scrambling_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool RevealRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:yosysZKP.RevealRequest)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated bool scrambling = 1;
      case 1: {
        if (tag == 8) {
         parse_scrambling:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 1, 8, input, this->mutable_scrambling())));
        } else if (tag == 10) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, this->mutable_scrambling())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(8)) goto parse_scrambling;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:yosysZKP.RevealRequest)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:yosysZKP.RevealRequest)
  return false;
#undef DO_
}

void RevealRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:yosysZKP.RevealRequest)
  // repeated bool scrambling = 1;
  for (int i = 0; i < this->scrambling_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(
      1, this->scrambling(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:yosysZKP.RevealRequest)
}

::google::protobuf::uint8* RevealRequest::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:yosysZKP.RevealRequest)
  // repeated bool scrambling = 1;
  for (int i = 0; i < this->scrambling_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteBoolToArray(1, this->scrambling(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:yosysZKP.RevealRequest)
  return target;
}

int RevealRequest::ByteSize() const {
  int total_size = 0;

  // repeated bool scrambling = 1;
  {
    int data_size = 0;
    data_size = 1 * this->scrambling_size();
    total_size += 1 * this->scrambling_size() + data_size;
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RevealRequest::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const RevealRequest* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const RevealRequest*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void RevealRequest::MergeFrom(const RevealRequest& from) {
  GOOGLE_CHECK_NE(&from, this);
  scrambling_.MergeFrom(from.scrambling_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void RevealRequest::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void RevealRequest::CopyFrom(const RevealRequest& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RevealRequest::IsInitialized() const {

  return true;
}

void RevealRequest::Swap(RevealRequest* other) {
  if (other != this) {
    scrambling_.Swap(&other->scrambling_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata RevealRequest::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = RevealRequest_descriptor_;
  metadata.reflection = RevealRequest_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ProveeState::kScramblingFieldNumber;
const int ProveeState::kCommitmentFieldNumber;
#endif  // !_MSC_VER

ProveeState::ProveeState()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:yosysZKP.ProveeState)
}

void ProveeState::InitAsDefaultInstance() {
  commitment_ = const_cast< ::yosysZKP::Commitment*>(&::yosysZKP::Commitment::default_instance());
}

ProveeState::ProveeState(const ProveeState& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:yosysZKP.ProveeState)
}

void ProveeState::SharedCtor() {
  _cached_size_ = 0;
  scrambling_ = false;
  commitment_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ProveeState::~ProveeState() {
  // @@protoc_insertion_point(destructor:yosysZKP.ProveeState)
  SharedDtor();
}

void ProveeState::SharedDtor() {
  if (this != default_instance_) {
    delete commitment_;
  }
}

void ProveeState::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ProveeState::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ProveeState_descriptor_;
}

const ProveeState& ProveeState::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();
  return *default_instance_;
}

ProveeState* ProveeState::default_instance_ = NULL;

ProveeState* ProveeState::New() const {
  return new ProveeState;
}

void ProveeState::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    scrambling_ = false;
    if (has_commitment()) {
      if (commitment_ != NULL) commitment_->::yosysZKP::Commitment::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ProveeState::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:yosysZKP.ProveeState)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required bool scrambling = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &scrambling_)));
          set_has_scrambling();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_commitment;
        break;
      }

      // required .yosysZKP.Commitment commitment = 2;
      case 2: {
        if (tag == 18) {
         parse_commitment:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_commitment()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:yosysZKP.ProveeState)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:yosysZKP.ProveeState)
  return false;
#undef DO_
}

void ProveeState::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:yosysZKP.ProveeState)
  // required bool scrambling = 1;
  if (has_scrambling()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(1, this->scrambling(), output);
  }

  // required .yosysZKP.Commitment commitment = 2;
  if (has_commitment()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->commitment(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:yosysZKP.ProveeState)
}

::google::protobuf::uint8* ProveeState::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:yosysZKP.ProveeState)
  // required bool scrambling = 1;
  if (has_scrambling()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(1, this->scrambling(), target);
  }

  // required .yosysZKP.Commitment commitment = 2;
  if (has_commitment()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->commitment(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:yosysZKP.ProveeState)
  return target;
}

int ProveeState::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required bool scrambling = 1;
    if (has_scrambling()) {
      total_size += 1 + 1;
    }

    // required .yosysZKP.Commitment commitment = 2;
    if (has_commitment()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->commitment());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ProveeState::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ProveeState* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ProveeState*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ProveeState::MergeFrom(const ProveeState& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_scrambling()) {
      set_scrambling(from.scrambling());
    }
    if (from.has_commitment()) {
      mutable_commitment()->::yosysZKP::Commitment::MergeFrom(from.commitment());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ProveeState::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ProveeState::CopyFrom(const ProveeState& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ProveeState::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void ProveeState::Swap(ProveeState* other) {
  if (other != this) {
    std::swap(scrambling_, other->scrambling_);
    std::swap(commitment_, other->commitment_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ProveeState::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ProveeState_descriptor_;
  metadata.reflection = ProveeState_reflection_;
  return metadata;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace yosysZKP

// @@protoc_insertion_point(global_scope)
