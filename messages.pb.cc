// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: messages.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "messages.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace yosysZKP {

namespace {

const ::google::protobuf::Descriptor* WireValues_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  WireValues_reflection_ = NULL;
const ::google::protobuf::Descriptor* WireValues_Entry_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  WireValues_Entry_reflection_ = NULL;
const ::google::protobuf::Descriptor* TruthTableEntry_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  TruthTableEntry_reflection_ = NULL;
const ::google::protobuf::Descriptor* TruthTable_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  TruthTable_reflection_ = NULL;
const ::google::protobuf::Descriptor* TableCommitment_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  TableCommitment_reflection_ = NULL;
const ::google::protobuf::Descriptor* Commitment_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Commitment_reflection_ = NULL;
const ::google::protobuf::Descriptor* Commitments_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Commitments_reflection_ = NULL;
const ::google::protobuf::Descriptor* ExecutionReveal_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ExecutionReveal_reflection_ = NULL;
const ::google::protobuf::Descriptor* ScramblingReveal_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ScramblingReveal_reflection_ = NULL;
const ::google::protobuf::Descriptor* ProverSecret_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ProverSecret_reflection_ = NULL;
const ::google::protobuf::Descriptor* ProverState_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ProverState_reflection_ = NULL;
const ::google::protobuf::Descriptor* RevealRequest_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  RevealRequest_reflection_ = NULL;
const ::google::protobuf::Descriptor* ProveeState_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ProveeState_reflection_ = NULL;

}  // namespace


void protobuf_AssignDesc_messages_2eproto() {
  protobuf_AddDesc_messages_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "messages.proto");
  GOOGLE_CHECK(file != NULL);
  WireValues_descriptor_ = file->message_type(0);
  static const int WireValues_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WireValues, entries_),
  };
  WireValues_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      WireValues_descriptor_,
      WireValues::default_instance_,
      WireValues_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WireValues, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WireValues, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(WireValues));
  WireValues_Entry_descriptor_ = WireValues_descriptor_->nested_type(0);
  static const int WireValues_Entry_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WireValues_Entry, wirename_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WireValues_Entry, value_),
  };
  WireValues_Entry_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      WireValues_Entry_descriptor_,
      WireValues_Entry::default_instance_,
      WireValues_Entry_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WireValues_Entry, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WireValues_Entry, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(WireValues_Entry));
  TruthTableEntry_descriptor_ = file->message_type(1);
  static const int TruthTableEntry_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TruthTableEntry, inputs_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TruthTableEntry, outputs_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TruthTableEntry, nonce_),
  };
  TruthTableEntry_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      TruthTableEntry_descriptor_,
      TruthTableEntry::default_instance_,
      TruthTableEntry_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TruthTableEntry, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TruthTableEntry, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(TruthTableEntry));
  TruthTable_descriptor_ = file->message_type(2);
  static const int TruthTable_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TruthTable, entries_),
  };
  TruthTable_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      TruthTable_descriptor_,
      TruthTable::default_instance_,
      TruthTable_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TruthTable, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TruthTable, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(TruthTable));
  TableCommitment_descriptor_ = file->message_type(3);
  static const int TableCommitment_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TableCommitment, entryhashes_),
  };
  TableCommitment_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      TableCommitment_descriptor_,
      TableCommitment::default_instance_,
      TableCommitment_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TableCommitment, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TableCommitment, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(TableCommitment));
  Commitment_descriptor_ = file->message_type(4);
  static const int Commitment_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Commitment, output_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Commitment, gatehashes_),
  };
  Commitment_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Commitment_descriptor_,
      Commitment::default_instance_,
      Commitment_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Commitment, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Commitment, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Commitment));
  Commitments_descriptor_ = file->message_type(5);
  static const int Commitments_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Commitments, rounds_),
  };
  Commitments_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Commitments_descriptor_,
      Commitments::default_instance_,
      Commitments_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Commitments, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Commitments, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Commitments));
  ExecutionReveal_descriptor_ = file->message_type(6);
  static const int ExecutionReveal_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ExecutionReveal, exec_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ExecutionReveal, entries_),
  };
  ExecutionReveal_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ExecutionReveal_descriptor_,
      ExecutionReveal::default_instance_,
      ExecutionReveal_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ExecutionReveal, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ExecutionReveal, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ExecutionReveal));
  ScramblingReveal_descriptor_ = file->message_type(7);
  static const int ScramblingReveal_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ScramblingReveal, keys_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ScramblingReveal, gates_),
  };
  ScramblingReveal_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ScramblingReveal_descriptor_,
      ScramblingReveal::default_instance_,
      ScramblingReveal_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ScramblingReveal, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ScramblingReveal, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ScramblingReveal));
  ProverSecret_descriptor_ = file->message_type(8);
  static const int ProverSecret_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ProverSecret, execution_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ProverSecret, scrambling_),
  };
  ProverSecret_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ProverSecret_descriptor_,
      ProverSecret::default_instance_,
      ProverSecret_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ProverSecret, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ProverSecret, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ProverSecret));
  ProverState_descriptor_ = file->message_type(9);
  static const int ProverState_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ProverState, round_),
  };
  ProverState_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ProverState_descriptor_,
      ProverState::default_instance_,
      ProverState_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ProverState, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ProverState, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ProverState));
  RevealRequest_descriptor_ = file->message_type(10);
  static const int RevealRequest_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RevealRequest, scrambling_),
  };
  RevealRequest_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      RevealRequest_descriptor_,
      RevealRequest::default_instance_,
      RevealRequest_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RevealRequest, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RevealRequest, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(RevealRequest));
  ProveeState_descriptor_ = file->message_type(11);
  static const int ProveeState_offsets_[5] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ProveeState, output_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ProveeState, security_param_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ProveeState, confidence_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ProveeState, commitment_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ProveeState, request_),
  };
  ProveeState_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ProveeState_descriptor_,
      ProveeState::default_instance_,
      ProveeState_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ProveeState, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ProveeState, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ProveeState));
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_messages_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    WireValues_descriptor_, &WireValues::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    WireValues_Entry_descriptor_, &WireValues_Entry::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    TruthTableEntry_descriptor_, &TruthTableEntry::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    TruthTable_descriptor_, &TruthTable::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    TableCommitment_descriptor_, &TableCommitment::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Commitment_descriptor_, &Commitment::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Commitments_descriptor_, &Commitments::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ExecutionReveal_descriptor_, &ExecutionReveal::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ScramblingReveal_descriptor_, &ScramblingReveal::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ProverSecret_descriptor_, &ProverSecret::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ProverState_descriptor_, &ProverState::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    RevealRequest_descriptor_, &RevealRequest::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ProveeState_descriptor_, &ProveeState::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_messages_2eproto() {
  delete WireValues::default_instance_;
  delete WireValues_reflection_;
  delete WireValues_Entry::default_instance_;
  delete WireValues_Entry_reflection_;
  delete TruthTableEntry::default_instance_;
  delete TruthTableEntry_reflection_;
  delete TruthTable::default_instance_;
  delete TruthTable_reflection_;
  delete TableCommitment::default_instance_;
  delete TableCommitment_reflection_;
  delete Commitment::default_instance_;
  delete Commitment_reflection_;
  delete Commitments::default_instance_;
  delete Commitments_reflection_;
  delete ExecutionReveal::default_instance_;
  delete ExecutionReveal_reflection_;
  delete ScramblingReveal::default_instance_;
  delete ScramblingReveal_reflection_;
  delete ProverSecret::default_instance_;
  delete ProverSecret_reflection_;
  delete ProverState::default_instance_;
  delete ProverState_reflection_;
  delete RevealRequest::default_instance_;
  delete RevealRequest_reflection_;
  delete ProveeState::default_instance_;
  delete ProveeState_reflection_;
}

void protobuf_AddDesc_messages_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\016messages.proto\022\010yosysZKP\"c\n\nWireValues"
    "\022+\n\007entries\030\001 \003(\0132\032.yosysZKP.WireValues."
    "Entry\032(\n\005Entry\022\020\n\010wirename\030\001 \002(\t\022\r\n\005valu"
    "e\030\002 \002(\010\"A\n\017TruthTableEntry\022\016\n\006inputs\030\001 \003"
    "(\010\022\017\n\007outputs\030\002 \003(\010\022\r\n\005nonce\030\003 \002(\014\"8\n\nTr"
    "uthTable\022*\n\007entries\030\001 \003(\0132\031.yosysZKP.Tru"
    "thTableEntry\"&\n\017TableCommitment\022\023\n\013entry"
    "hashes\030\001 \003(\014\"K\n\nCommitment\022\016\n\006output\030\001 \003"
    "(\010\022-\n\ngatehashes\030\002 \003(\0132\031.yosysZKP.TableC"
    "ommitment\"3\n\013Commitments\022$\n\006rounds\030\002 \003(\013"
    "2\024.yosysZKP.Commitment\"a\n\017ExecutionRevea"
    "l\022\"\n\004exec\030\001 \002(\0132\024.yosysZKP.WireValues\022*\n"
    "\007entries\030\002 \003(\0132\031.yosysZKP.TruthTableEntr"
    "y\"[\n\020ScramblingReveal\022\"\n\004keys\030\001 \002(\0132\024.yo"
    "sysZKP.WireValues\022#\n\005gates\030\002 \003(\0132\024.yosys"
    "ZKP.TruthTable\"l\n\014ProverSecret\022,\n\texecut"
    "ion\030\001 \001(\0132\031.yosysZKP.ExecutionReveal\022.\n\n"
    "scrambling\030\002 \001(\0132\032.yosysZKP.ScramblingRe"
    "veal\"4\n\013ProverState\022%\n\005round\030\001 \003(\0132\026.yos"
    "ysZKP.ProverSecret\"#\n\rRevealRequest\022\022\n\ns"
    "crambling\030\001 \003(\010\"\236\001\n\013ProveeState\022\016\n\006outpu"
    "t\030\001 \003(\010\022\026\n\016security_param\030\002 \002(\005\022\022\n\nconfi"
    "dence\030\003 \002(\005\022)\n\ncommitment\030\004 \002(\0132\025.yosysZ"
    "KP.Commitments\022(\n\007request\030\005 \002(\0132\027.yosysZ"
    "KP.RevealRequest", 976);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "messages.proto", &protobuf_RegisterTypes);
  WireValues::default_instance_ = new WireValues();
  WireValues_Entry::default_instance_ = new WireValues_Entry();
  TruthTableEntry::default_instance_ = new TruthTableEntry();
  TruthTable::default_instance_ = new TruthTable();
  TableCommitment::default_instance_ = new TableCommitment();
  Commitment::default_instance_ = new Commitment();
  Commitments::default_instance_ = new Commitments();
  ExecutionReveal::default_instance_ = new ExecutionReveal();
  ScramblingReveal::default_instance_ = new ScramblingReveal();
  ProverSecret::default_instance_ = new ProverSecret();
  ProverState::default_instance_ = new ProverState();
  RevealRequest::default_instance_ = new RevealRequest();
  ProveeState::default_instance_ = new ProveeState();
  WireValues::default_instance_->InitAsDefaultInstance();
  WireValues_Entry::default_instance_->InitAsDefaultInstance();
  TruthTableEntry::default_instance_->InitAsDefaultInstance();
  TruthTable::default_instance_->InitAsDefaultInstance();
  TableCommitment::default_instance_->InitAsDefaultInstance();
  Commitment::default_instance_->InitAsDefaultInstance();
  Commitments::default_instance_->InitAsDefaultInstance();
  ExecutionReveal::default_instance_->InitAsDefaultInstance();
  ScramblingReveal::default_instance_->InitAsDefaultInstance();
  ProverSecret::default_instance_->InitAsDefaultInstance();
  ProverState::default_instance_->InitAsDefaultInstance();
  RevealRequest::default_instance_->InitAsDefaultInstance();
  ProveeState::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_messages_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_messages_2eproto {
  StaticDescriptorInitializer_messages_2eproto() {
    protobuf_AddDesc_messages_2eproto();
  }
} static_descriptor_initializer_messages_2eproto_;

// ===================================================================

#ifndef _MSC_VER
const int WireValues_Entry::kWirenameFieldNumber;
const int WireValues_Entry::kValueFieldNumber;
#endif  // !_MSC_VER

WireValues_Entry::WireValues_Entry()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:yosysZKP.WireValues.Entry)
}

void WireValues_Entry::InitAsDefaultInstance() {
}

WireValues_Entry::WireValues_Entry(const WireValues_Entry& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:yosysZKP.WireValues.Entry)
}

void WireValues_Entry::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  wirename_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  value_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

WireValues_Entry::~WireValues_Entry() {
  // @@protoc_insertion_point(destructor:yosysZKP.WireValues.Entry)
  SharedDtor();
}

void WireValues_Entry::SharedDtor() {
  if (wirename_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete wirename_;
  }
  if (this != default_instance_) {
  }
}

void WireValues_Entry::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* WireValues_Entry::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return WireValues_Entry_descriptor_;
}

const WireValues_Entry& WireValues_Entry::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();
  return *default_instance_;
}

WireValues_Entry* WireValues_Entry::default_instance_ = NULL;

WireValues_Entry* WireValues_Entry::New() const {
  return new WireValues_Entry;
}

void WireValues_Entry::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    if (has_wirename()) {
      if (wirename_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        wirename_->clear();
      }
    }
    value_ = false;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool WireValues_Entry::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:yosysZKP.WireValues.Entry)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string wirename = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_wirename()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->wirename().data(), this->wirename().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "wirename");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_value;
        break;
      }

      // required bool value = 2;
      case 2: {
        if (tag == 16) {
         parse_value:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &value_)));
          set_has_value();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:yosysZKP.WireValues.Entry)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:yosysZKP.WireValues.Entry)
  return false;
#undef DO_
}

void WireValues_Entry::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:yosysZKP.WireValues.Entry)
  // required string wirename = 1;
  if (has_wirename()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->wirename().data(), this->wirename().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "wirename");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->wirename(), output);
  }

  // required bool value = 2;
  if (has_value()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(2, this->value(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:yosysZKP.WireValues.Entry)
}

::google::protobuf::uint8* WireValues_Entry::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:yosysZKP.WireValues.Entry)
  // required string wirename = 1;
  if (has_wirename()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->wirename().data(), this->wirename().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "wirename");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->wirename(), target);
  }

  // required bool value = 2;
  if (has_value()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(2, this->value(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:yosysZKP.WireValues.Entry)
  return target;
}

int WireValues_Entry::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string wirename = 1;
    if (has_wirename()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->wirename());
    }

    // required bool value = 2;
    if (has_value()) {
      total_size += 1 + 1;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void WireValues_Entry::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const WireValues_Entry* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const WireValues_Entry*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void WireValues_Entry::MergeFrom(const WireValues_Entry& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_wirename()) {
      set_wirename(from.wirename());
    }
    if (from.has_value()) {
      set_value(from.value());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void WireValues_Entry::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void WireValues_Entry::CopyFrom(const WireValues_Entry& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool WireValues_Entry::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void WireValues_Entry::Swap(WireValues_Entry* other) {
  if (other != this) {
    std::swap(wirename_, other->wirename_);
    std::swap(value_, other->value_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata WireValues_Entry::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = WireValues_Entry_descriptor_;
  metadata.reflection = WireValues_Entry_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int WireValues::kEntriesFieldNumber;
#endif  // !_MSC_VER

WireValues::WireValues()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:yosysZKP.WireValues)
}

void WireValues::InitAsDefaultInstance() {
}

WireValues::WireValues(const WireValues& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:yosysZKP.WireValues)
}

void WireValues::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

WireValues::~WireValues() {
  // @@protoc_insertion_point(destructor:yosysZKP.WireValues)
  SharedDtor();
}

void WireValues::SharedDtor() {
  if (this != default_instance_) {
  }
}

void WireValues::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* WireValues::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return WireValues_descriptor_;
}

const WireValues& WireValues::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();
  return *default_instance_;
}

WireValues* WireValues::default_instance_ = NULL;

WireValues* WireValues::New() const {
  return new WireValues;
}

void WireValues::Clear() {
  entries_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool WireValues::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:yosysZKP.WireValues)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .yosysZKP.WireValues.Entry entries = 1;
      case 1: {
        if (tag == 10) {
         parse_entries:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_entries()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_entries;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:yosysZKP.WireValues)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:yosysZKP.WireValues)
  return false;
#undef DO_
}

void WireValues::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:yosysZKP.WireValues)
  // repeated .yosysZKP.WireValues.Entry entries = 1;
  for (int i = 0; i < this->entries_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->entries(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:yosysZKP.WireValues)
}

::google::protobuf::uint8* WireValues::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:yosysZKP.WireValues)
  // repeated .yosysZKP.WireValues.Entry entries = 1;
  for (int i = 0; i < this->entries_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->entries(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:yosysZKP.WireValues)
  return target;
}

int WireValues::ByteSize() const {
  int total_size = 0;

  // repeated .yosysZKP.WireValues.Entry entries = 1;
  total_size += 1 * this->entries_size();
  for (int i = 0; i < this->entries_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->entries(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void WireValues::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const WireValues* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const WireValues*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void WireValues::MergeFrom(const WireValues& from) {
  GOOGLE_CHECK_NE(&from, this);
  entries_.MergeFrom(from.entries_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void WireValues::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void WireValues::CopyFrom(const WireValues& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool WireValues::IsInitialized() const {

  if (!::google::protobuf::internal::AllAreInitialized(this->entries())) return false;
  return true;
}

void WireValues::Swap(WireValues* other) {
  if (other != this) {
    entries_.Swap(&other->entries_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata WireValues::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = WireValues_descriptor_;
  metadata.reflection = WireValues_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int TruthTableEntry::kInputsFieldNumber;
const int TruthTableEntry::kOutputsFieldNumber;
const int TruthTableEntry::kNonceFieldNumber;
#endif  // !_MSC_VER

TruthTableEntry::TruthTableEntry()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:yosysZKP.TruthTableEntry)
}

void TruthTableEntry::InitAsDefaultInstance() {
}

TruthTableEntry::TruthTableEntry(const TruthTableEntry& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:yosysZKP.TruthTableEntry)
}

void TruthTableEntry::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  nonce_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TruthTableEntry::~TruthTableEntry() {
  // @@protoc_insertion_point(destructor:yosysZKP.TruthTableEntry)
  SharedDtor();
}

void TruthTableEntry::SharedDtor() {
  if (nonce_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete nonce_;
  }
  if (this != default_instance_) {
  }
}

void TruthTableEntry::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* TruthTableEntry::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TruthTableEntry_descriptor_;
}

const TruthTableEntry& TruthTableEntry::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();
  return *default_instance_;
}

TruthTableEntry* TruthTableEntry::default_instance_ = NULL;

TruthTableEntry* TruthTableEntry::New() const {
  return new TruthTableEntry;
}

void TruthTableEntry::Clear() {
  if (has_nonce()) {
    if (nonce_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
      nonce_->clear();
    }
  }
  inputs_.Clear();
  outputs_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool TruthTableEntry::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:yosysZKP.TruthTableEntry)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated bool inputs = 1;
      case 1: {
        if (tag == 8) {
         parse_inputs:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 1, 8, input, this->mutable_inputs())));
        } else if (tag == 10) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, this->mutable_inputs())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(8)) goto parse_inputs;
        if (input->ExpectTag(16)) goto parse_outputs;
        break;
      }

      // repeated bool outputs = 2;
      case 2: {
        if (tag == 16) {
         parse_outputs:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 1, 16, input, this->mutable_outputs())));
        } else if (tag == 18) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, this->mutable_outputs())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_outputs;
        if (input->ExpectTag(26)) goto parse_nonce;
        break;
      }

      // required bytes nonce = 3;
      case 3: {
        if (tag == 26) {
         parse_nonce:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_nonce()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:yosysZKP.TruthTableEntry)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:yosysZKP.TruthTableEntry)
  return false;
#undef DO_
}

void TruthTableEntry::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:yosysZKP.TruthTableEntry)
  // repeated bool inputs = 1;
  for (int i = 0; i < this->inputs_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(
      1, this->inputs(i), output);
  }

  // repeated bool outputs = 2;
  for (int i = 0; i < this->outputs_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(
      2, this->outputs(i), output);
  }

  // required bytes nonce = 3;
  if (has_nonce()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      3, this->nonce(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:yosysZKP.TruthTableEntry)
}

::google::protobuf::uint8* TruthTableEntry::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:yosysZKP.TruthTableEntry)
  // repeated bool inputs = 1;
  for (int i = 0; i < this->inputs_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteBoolToArray(1, this->inputs(i), target);
  }

  // repeated bool outputs = 2;
  for (int i = 0; i < this->outputs_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteBoolToArray(2, this->outputs(i), target);
  }

  // required bytes nonce = 3;
  if (has_nonce()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        3, this->nonce(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:yosysZKP.TruthTableEntry)
  return target;
}

int TruthTableEntry::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[2 / 32] & (0xffu << (2 % 32))) {
    // required bytes nonce = 3;
    if (has_nonce()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->nonce());
    }

  }
  // repeated bool inputs = 1;
  {
    int data_size = 0;
    data_size = 1 * this->inputs_size();
    total_size += 1 * this->inputs_size() + data_size;
  }

  // repeated bool outputs = 2;
  {
    int data_size = 0;
    data_size = 1 * this->outputs_size();
    total_size += 1 * this->outputs_size() + data_size;
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TruthTableEntry::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const TruthTableEntry* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const TruthTableEntry*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void TruthTableEntry::MergeFrom(const TruthTableEntry& from) {
  GOOGLE_CHECK_NE(&from, this);
  inputs_.MergeFrom(from.inputs_);
  outputs_.MergeFrom(from.outputs_);
  if (from._has_bits_[2 / 32] & (0xffu << (2 % 32))) {
    if (from.has_nonce()) {
      set_nonce(from.nonce());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void TruthTableEntry::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TruthTableEntry::CopyFrom(const TruthTableEntry& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TruthTableEntry::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000004) != 0x00000004) return false;

  return true;
}

void TruthTableEntry::Swap(TruthTableEntry* other) {
  if (other != this) {
    inputs_.Swap(&other->inputs_);
    outputs_.Swap(&other->outputs_);
    std::swap(nonce_, other->nonce_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata TruthTableEntry::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = TruthTableEntry_descriptor_;
  metadata.reflection = TruthTableEntry_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int TruthTable::kEntriesFieldNumber;
#endif  // !_MSC_VER

TruthTable::TruthTable()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:yosysZKP.TruthTable)
}

void TruthTable::InitAsDefaultInstance() {
}

TruthTable::TruthTable(const TruthTable& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:yosysZKP.TruthTable)
}

void TruthTable::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TruthTable::~TruthTable() {
  // @@protoc_insertion_point(destructor:yosysZKP.TruthTable)
  SharedDtor();
}

void TruthTable::SharedDtor() {
  if (this != default_instance_) {
  }
}

void TruthTable::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* TruthTable::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TruthTable_descriptor_;
}

const TruthTable& TruthTable::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();
  return *default_instance_;
}

TruthTable* TruthTable::default_instance_ = NULL;

TruthTable* TruthTable::New() const {
  return new TruthTable;
}

void TruthTable::Clear() {
  entries_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool TruthTable::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:yosysZKP.TruthTable)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .yosysZKP.TruthTableEntry entries = 1;
      case 1: {
        if (tag == 10) {
         parse_entries:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_entries()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_entries;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:yosysZKP.TruthTable)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:yosysZKP.TruthTable)
  return false;
#undef DO_
}

void TruthTable::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:yosysZKP.TruthTable)
  // repeated .yosysZKP.TruthTableEntry entries = 1;
  for (int i = 0; i < this->entries_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->entries(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:yosysZKP.TruthTable)
}

::google::protobuf::uint8* TruthTable::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:yosysZKP.TruthTable)
  // repeated .yosysZKP.TruthTableEntry entries = 1;
  for (int i = 0; i < this->entries_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->entries(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:yosysZKP.TruthTable)
  return target;
}

int TruthTable::ByteSize() const {
  int total_size = 0;

  // repeated .yosysZKP.TruthTableEntry entries = 1;
  total_size += 1 * this->entries_size();
  for (int i = 0; i < this->entries_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->entries(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TruthTable::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const TruthTable* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const TruthTable*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void TruthTable::MergeFrom(const TruthTable& from) {
  GOOGLE_CHECK_NE(&from, this);
  entries_.MergeFrom(from.entries_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void TruthTable::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TruthTable::CopyFrom(const TruthTable& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TruthTable::IsInitialized() const {

  if (!::google::protobuf::internal::AllAreInitialized(this->entries())) return false;
  return true;
}

void TruthTable::Swap(TruthTable* other) {
  if (other != this) {
    entries_.Swap(&other->entries_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata TruthTable::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = TruthTable_descriptor_;
  metadata.reflection = TruthTable_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int TableCommitment::kEntryhashesFieldNumber;
#endif  // !_MSC_VER

TableCommitment::TableCommitment()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:yosysZKP.TableCommitment)
}

void TableCommitment::InitAsDefaultInstance() {
}

TableCommitment::TableCommitment(const TableCommitment& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:yosysZKP.TableCommitment)
}

void TableCommitment::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TableCommitment::~TableCommitment() {
  // @@protoc_insertion_point(destructor:yosysZKP.TableCommitment)
  SharedDtor();
}

void TableCommitment::SharedDtor() {
  if (this != default_instance_) {
  }
}

void TableCommitment::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* TableCommitment::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TableCommitment_descriptor_;
}

const TableCommitment& TableCommitment::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();
  return *default_instance_;
}

TableCommitment* TableCommitment::default_instance_ = NULL;

TableCommitment* TableCommitment::New() const {
  return new TableCommitment;
}

void TableCommitment::Clear() {
  entryhashes_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool TableCommitment::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:yosysZKP.TableCommitment)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated bytes entryhashes = 1;
      case 1: {
        if (tag == 10) {
         parse_entryhashes:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->add_entryhashes()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_entryhashes;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:yosysZKP.TableCommitment)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:yosysZKP.TableCommitment)
  return false;
#undef DO_
}

void TableCommitment::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:yosysZKP.TableCommitment)
  // repeated bytes entryhashes = 1;
  for (int i = 0; i < this->entryhashes_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteBytes(
      1, this->entryhashes(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:yosysZKP.TableCommitment)
}

::google::protobuf::uint8* TableCommitment::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:yosysZKP.TableCommitment)
  // repeated bytes entryhashes = 1;
  for (int i = 0; i < this->entryhashes_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteBytesToArray(1, this->entryhashes(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:yosysZKP.TableCommitment)
  return target;
}

int TableCommitment::ByteSize() const {
  int total_size = 0;

  // repeated bytes entryhashes = 1;
  total_size += 1 * this->entryhashes_size();
  for (int i = 0; i < this->entryhashes_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::BytesSize(
      this->entryhashes(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TableCommitment::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const TableCommitment* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const TableCommitment*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void TableCommitment::MergeFrom(const TableCommitment& from) {
  GOOGLE_CHECK_NE(&from, this);
  entryhashes_.MergeFrom(from.entryhashes_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void TableCommitment::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TableCommitment::CopyFrom(const TableCommitment& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TableCommitment::IsInitialized() const {

  return true;
}

void TableCommitment::Swap(TableCommitment* other) {
  if (other != this) {
    entryhashes_.Swap(&other->entryhashes_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata TableCommitment::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = TableCommitment_descriptor_;
  metadata.reflection = TableCommitment_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Commitment::kOutputFieldNumber;
const int Commitment::kGatehashesFieldNumber;
#endif  // !_MSC_VER

Commitment::Commitment()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:yosysZKP.Commitment)
}

void Commitment::InitAsDefaultInstance() {
}

Commitment::Commitment(const Commitment& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:yosysZKP.Commitment)
}

void Commitment::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Commitment::~Commitment() {
  // @@protoc_insertion_point(destructor:yosysZKP.Commitment)
  SharedDtor();
}

void Commitment::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Commitment::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Commitment::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Commitment_descriptor_;
}

const Commitment& Commitment::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();
  return *default_instance_;
}

Commitment* Commitment::default_instance_ = NULL;

Commitment* Commitment::New() const {
  return new Commitment;
}

void Commitment::Clear() {
  output_.Clear();
  gatehashes_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Commitment::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:yosysZKP.Commitment)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated bool output = 1;
      case 1: {
        if (tag == 8) {
         parse_output:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 1, 8, input, this->mutable_output())));
        } else if (tag == 10) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, this->mutable_output())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(8)) goto parse_output;
        if (input->ExpectTag(18)) goto parse_gatehashes;
        break;
      }

      // repeated .yosysZKP.TableCommitment gatehashes = 2;
      case 2: {
        if (tag == 18) {
         parse_gatehashes:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_gatehashes()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_gatehashes;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:yosysZKP.Commitment)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:yosysZKP.Commitment)
  return false;
#undef DO_
}

void Commitment::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:yosysZKP.Commitment)
  // repeated bool output = 1;
  for (int i = 0; i < this->output_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(
      1, this->output(i), output);
  }

  // repeated .yosysZKP.TableCommitment gatehashes = 2;
  for (int i = 0; i < this->gatehashes_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->gatehashes(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:yosysZKP.Commitment)
}

::google::protobuf::uint8* Commitment::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:yosysZKP.Commitment)
  // repeated bool output = 1;
  for (int i = 0; i < this->output_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteBoolToArray(1, this->output(i), target);
  }

  // repeated .yosysZKP.TableCommitment gatehashes = 2;
  for (int i = 0; i < this->gatehashes_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->gatehashes(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:yosysZKP.Commitment)
  return target;
}

int Commitment::ByteSize() const {
  int total_size = 0;

  // repeated bool output = 1;
  {
    int data_size = 0;
    data_size = 1 * this->output_size();
    total_size += 1 * this->output_size() + data_size;
  }

  // repeated .yosysZKP.TableCommitment gatehashes = 2;
  total_size += 1 * this->gatehashes_size();
  for (int i = 0; i < this->gatehashes_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->gatehashes(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Commitment::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Commitment* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Commitment*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Commitment::MergeFrom(const Commitment& from) {
  GOOGLE_CHECK_NE(&from, this);
  output_.MergeFrom(from.output_);
  gatehashes_.MergeFrom(from.gatehashes_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Commitment::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Commitment::CopyFrom(const Commitment& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Commitment::IsInitialized() const {

  return true;
}

void Commitment::Swap(Commitment* other) {
  if (other != this) {
    output_.Swap(&other->output_);
    gatehashes_.Swap(&other->gatehashes_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Commitment::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Commitment_descriptor_;
  metadata.reflection = Commitment_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Commitments::kRoundsFieldNumber;
#endif  // !_MSC_VER

Commitments::Commitments()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:yosysZKP.Commitments)
}

void Commitments::InitAsDefaultInstance() {
}

Commitments::Commitments(const Commitments& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:yosysZKP.Commitments)
}

void Commitments::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Commitments::~Commitments() {
  // @@protoc_insertion_point(destructor:yosysZKP.Commitments)
  SharedDtor();
}

void Commitments::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Commitments::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Commitments::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Commitments_descriptor_;
}

const Commitments& Commitments::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();
  return *default_instance_;
}

Commitments* Commitments::default_instance_ = NULL;

Commitments* Commitments::New() const {
  return new Commitments;
}

void Commitments::Clear() {
  rounds_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Commitments::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:yosysZKP.Commitments)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .yosysZKP.Commitment rounds = 2;
      case 2: {
        if (tag == 18) {
         parse_rounds:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_rounds()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_rounds;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:yosysZKP.Commitments)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:yosysZKP.Commitments)
  return false;
#undef DO_
}

void Commitments::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:yosysZKP.Commitments)
  // repeated .yosysZKP.Commitment rounds = 2;
  for (int i = 0; i < this->rounds_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->rounds(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:yosysZKP.Commitments)
}

::google::protobuf::uint8* Commitments::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:yosysZKP.Commitments)
  // repeated .yosysZKP.Commitment rounds = 2;
  for (int i = 0; i < this->rounds_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->rounds(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:yosysZKP.Commitments)
  return target;
}

int Commitments::ByteSize() const {
  int total_size = 0;

  // repeated .yosysZKP.Commitment rounds = 2;
  total_size += 1 * this->rounds_size();
  for (int i = 0; i < this->rounds_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->rounds(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Commitments::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Commitments* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Commitments*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Commitments::MergeFrom(const Commitments& from) {
  GOOGLE_CHECK_NE(&from, this);
  rounds_.MergeFrom(from.rounds_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Commitments::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Commitments::CopyFrom(const Commitments& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Commitments::IsInitialized() const {

  return true;
}

void Commitments::Swap(Commitments* other) {
  if (other != this) {
    rounds_.Swap(&other->rounds_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Commitments::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Commitments_descriptor_;
  metadata.reflection = Commitments_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ExecutionReveal::kExecFieldNumber;
const int ExecutionReveal::kEntriesFieldNumber;
#endif  // !_MSC_VER

ExecutionReveal::ExecutionReveal()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:yosysZKP.ExecutionReveal)
}

void ExecutionReveal::InitAsDefaultInstance() {
  exec_ = const_cast< ::yosysZKP::WireValues*>(&::yosysZKP::WireValues::default_instance());
}

ExecutionReveal::ExecutionReveal(const ExecutionReveal& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:yosysZKP.ExecutionReveal)
}

void ExecutionReveal::SharedCtor() {
  _cached_size_ = 0;
  exec_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ExecutionReveal::~ExecutionReveal() {
  // @@protoc_insertion_point(destructor:yosysZKP.ExecutionReveal)
  SharedDtor();
}

void ExecutionReveal::SharedDtor() {
  if (this != default_instance_) {
    delete exec_;
  }
}

void ExecutionReveal::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ExecutionReveal::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ExecutionReveal_descriptor_;
}

const ExecutionReveal& ExecutionReveal::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();
  return *default_instance_;
}

ExecutionReveal* ExecutionReveal::default_instance_ = NULL;

ExecutionReveal* ExecutionReveal::New() const {
  return new ExecutionReveal;
}

void ExecutionReveal::Clear() {
  if (has_exec()) {
    if (exec_ != NULL) exec_->::yosysZKP::WireValues::Clear();
  }
  entries_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ExecutionReveal::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:yosysZKP.ExecutionReveal)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .yosysZKP.WireValues exec = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_exec()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_entries;
        break;
      }

      // repeated .yosysZKP.TruthTableEntry entries = 2;
      case 2: {
        if (tag == 18) {
         parse_entries:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_entries()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_entries;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:yosysZKP.ExecutionReveal)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:yosysZKP.ExecutionReveal)
  return false;
#undef DO_
}

void ExecutionReveal::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:yosysZKP.ExecutionReveal)
  // required .yosysZKP.WireValues exec = 1;
  if (has_exec()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->exec(), output);
  }

  // repeated .yosysZKP.TruthTableEntry entries = 2;
  for (int i = 0; i < this->entries_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->entries(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:yosysZKP.ExecutionReveal)
}

::google::protobuf::uint8* ExecutionReveal::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:yosysZKP.ExecutionReveal)
  // required .yosysZKP.WireValues exec = 1;
  if (has_exec()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->exec(), target);
  }

  // repeated .yosysZKP.TruthTableEntry entries = 2;
  for (int i = 0; i < this->entries_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->entries(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:yosysZKP.ExecutionReveal)
  return target;
}

int ExecutionReveal::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .yosysZKP.WireValues exec = 1;
    if (has_exec()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->exec());
    }

  }
  // repeated .yosysZKP.TruthTableEntry entries = 2;
  total_size += 1 * this->entries_size();
  for (int i = 0; i < this->entries_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->entries(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ExecutionReveal::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ExecutionReveal* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ExecutionReveal*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ExecutionReveal::MergeFrom(const ExecutionReveal& from) {
  GOOGLE_CHECK_NE(&from, this);
  entries_.MergeFrom(from.entries_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_exec()) {
      mutable_exec()->::yosysZKP::WireValues::MergeFrom(from.exec());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ExecutionReveal::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ExecutionReveal::CopyFrom(const ExecutionReveal& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ExecutionReveal::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_exec()) {
    if (!this->exec().IsInitialized()) return false;
  }
  if (!::google::protobuf::internal::AllAreInitialized(this->entries())) return false;
  return true;
}

void ExecutionReveal::Swap(ExecutionReveal* other) {
  if (other != this) {
    std::swap(exec_, other->exec_);
    entries_.Swap(&other->entries_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ExecutionReveal::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ExecutionReveal_descriptor_;
  metadata.reflection = ExecutionReveal_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ScramblingReveal::kKeysFieldNumber;
const int ScramblingReveal::kGatesFieldNumber;
#endif  // !_MSC_VER

ScramblingReveal::ScramblingReveal()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:yosysZKP.ScramblingReveal)
}

void ScramblingReveal::InitAsDefaultInstance() {
  keys_ = const_cast< ::yosysZKP::WireValues*>(&::yosysZKP::WireValues::default_instance());
}

ScramblingReveal::ScramblingReveal(const ScramblingReveal& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:yosysZKP.ScramblingReveal)
}

void ScramblingReveal::SharedCtor() {
  _cached_size_ = 0;
  keys_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ScramblingReveal::~ScramblingReveal() {
  // @@protoc_insertion_point(destructor:yosysZKP.ScramblingReveal)
  SharedDtor();
}

void ScramblingReveal::SharedDtor() {
  if (this != default_instance_) {
    delete keys_;
  }
}

void ScramblingReveal::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ScramblingReveal::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ScramblingReveal_descriptor_;
}

const ScramblingReveal& ScramblingReveal::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();
  return *default_instance_;
}

ScramblingReveal* ScramblingReveal::default_instance_ = NULL;

ScramblingReveal* ScramblingReveal::New() const {
  return new ScramblingReveal;
}

void ScramblingReveal::Clear() {
  if (has_keys()) {
    if (keys_ != NULL) keys_->::yosysZKP::WireValues::Clear();
  }
  gates_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ScramblingReveal::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:yosysZKP.ScramblingReveal)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .yosysZKP.WireValues keys = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_keys()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_gates;
        break;
      }

      // repeated .yosysZKP.TruthTable gates = 2;
      case 2: {
        if (tag == 18) {
         parse_gates:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_gates()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_gates;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:yosysZKP.ScramblingReveal)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:yosysZKP.ScramblingReveal)
  return false;
#undef DO_
}

void ScramblingReveal::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:yosysZKP.ScramblingReveal)
  // required .yosysZKP.WireValues keys = 1;
  if (has_keys()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->keys(), output);
  }

  // repeated .yosysZKP.TruthTable gates = 2;
  for (int i = 0; i < this->gates_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->gates(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:yosysZKP.ScramblingReveal)
}

::google::protobuf::uint8* ScramblingReveal::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:yosysZKP.ScramblingReveal)
  // required .yosysZKP.WireValues keys = 1;
  if (has_keys()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->keys(), target);
  }

  // repeated .yosysZKP.TruthTable gates = 2;
  for (int i = 0; i < this->gates_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->gates(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:yosysZKP.ScramblingReveal)
  return target;
}

int ScramblingReveal::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .yosysZKP.WireValues keys = 1;
    if (has_keys()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->keys());
    }

  }
  // repeated .yosysZKP.TruthTable gates = 2;
  total_size += 1 * this->gates_size();
  for (int i = 0; i < this->gates_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->gates(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ScramblingReveal::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ScramblingReveal* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ScramblingReveal*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ScramblingReveal::MergeFrom(const ScramblingReveal& from) {
  GOOGLE_CHECK_NE(&from, this);
  gates_.MergeFrom(from.gates_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_keys()) {
      mutable_keys()->::yosysZKP::WireValues::MergeFrom(from.keys());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ScramblingReveal::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ScramblingReveal::CopyFrom(const ScramblingReveal& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ScramblingReveal::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_keys()) {
    if (!this->keys().IsInitialized()) return false;
  }
  if (!::google::protobuf::internal::AllAreInitialized(this->gates())) return false;
  return true;
}

void ScramblingReveal::Swap(ScramblingReveal* other) {
  if (other != this) {
    std::swap(keys_, other->keys_);
    gates_.Swap(&other->gates_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ScramblingReveal::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ScramblingReveal_descriptor_;
  metadata.reflection = ScramblingReveal_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ProverSecret::kExecutionFieldNumber;
const int ProverSecret::kScramblingFieldNumber;
#endif  // !_MSC_VER

ProverSecret::ProverSecret()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:yosysZKP.ProverSecret)
}

void ProverSecret::InitAsDefaultInstance() {
  execution_ = const_cast< ::yosysZKP::ExecutionReveal*>(&::yosysZKP::ExecutionReveal::default_instance());
  scrambling_ = const_cast< ::yosysZKP::ScramblingReveal*>(&::yosysZKP::ScramblingReveal::default_instance());
}

ProverSecret::ProverSecret(const ProverSecret& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:yosysZKP.ProverSecret)
}

void ProverSecret::SharedCtor() {
  _cached_size_ = 0;
  execution_ = NULL;
  scrambling_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ProverSecret::~ProverSecret() {
  // @@protoc_insertion_point(destructor:yosysZKP.ProverSecret)
  SharedDtor();
}

void ProverSecret::SharedDtor() {
  if (this != default_instance_) {
    delete execution_;
    delete scrambling_;
  }
}

void ProverSecret::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ProverSecret::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ProverSecret_descriptor_;
}

const ProverSecret& ProverSecret::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();
  return *default_instance_;
}

ProverSecret* ProverSecret::default_instance_ = NULL;

ProverSecret* ProverSecret::New() const {
  return new ProverSecret;
}

void ProverSecret::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    if (has_execution()) {
      if (execution_ != NULL) execution_->::yosysZKP::ExecutionReveal::Clear();
    }
    if (has_scrambling()) {
      if (scrambling_ != NULL) scrambling_->::yosysZKP::ScramblingReveal::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ProverSecret::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:yosysZKP.ProverSecret)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .yosysZKP.ExecutionReveal execution = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_execution()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_scrambling;
        break;
      }

      // optional .yosysZKP.ScramblingReveal scrambling = 2;
      case 2: {
        if (tag == 18) {
         parse_scrambling:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_scrambling()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:yosysZKP.ProverSecret)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:yosysZKP.ProverSecret)
  return false;
#undef DO_
}

void ProverSecret::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:yosysZKP.ProverSecret)
  // optional .yosysZKP.ExecutionReveal execution = 1;
  if (has_execution()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->execution(), output);
  }

  // optional .yosysZKP.ScramblingReveal scrambling = 2;
  if (has_scrambling()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->scrambling(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:yosysZKP.ProverSecret)
}

::google::protobuf::uint8* ProverSecret::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:yosysZKP.ProverSecret)
  // optional .yosysZKP.ExecutionReveal execution = 1;
  if (has_execution()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->execution(), target);
  }

  // optional .yosysZKP.ScramblingReveal scrambling = 2;
  if (has_scrambling()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->scrambling(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:yosysZKP.ProverSecret)
  return target;
}

int ProverSecret::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .yosysZKP.ExecutionReveal execution = 1;
    if (has_execution()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->execution());
    }

    // optional .yosysZKP.ScramblingReveal scrambling = 2;
    if (has_scrambling()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->scrambling());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ProverSecret::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ProverSecret* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ProverSecret*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ProverSecret::MergeFrom(const ProverSecret& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_execution()) {
      mutable_execution()->::yosysZKP::ExecutionReveal::MergeFrom(from.execution());
    }
    if (from.has_scrambling()) {
      mutable_scrambling()->::yosysZKP::ScramblingReveal::MergeFrom(from.scrambling());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ProverSecret::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ProverSecret::CopyFrom(const ProverSecret& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ProverSecret::IsInitialized() const {

  if (has_execution()) {
    if (!this->execution().IsInitialized()) return false;
  }
  if (has_scrambling()) {
    if (!this->scrambling().IsInitialized()) return false;
  }
  return true;
}

void ProverSecret::Swap(ProverSecret* other) {
  if (other != this) {
    std::swap(execution_, other->execution_);
    std::swap(scrambling_, other->scrambling_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ProverSecret::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ProverSecret_descriptor_;
  metadata.reflection = ProverSecret_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ProverState::kRoundFieldNumber;
#endif  // !_MSC_VER

ProverState::ProverState()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:yosysZKP.ProverState)
}

void ProverState::InitAsDefaultInstance() {
}

ProverState::ProverState(const ProverState& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:yosysZKP.ProverState)
}

void ProverState::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ProverState::~ProverState() {
  // @@protoc_insertion_point(destructor:yosysZKP.ProverState)
  SharedDtor();
}

void ProverState::SharedDtor() {
  if (this != default_instance_) {
  }
}

void ProverState::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ProverState::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ProverState_descriptor_;
}

const ProverState& ProverState::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();
  return *default_instance_;
}

ProverState* ProverState::default_instance_ = NULL;

ProverState* ProverState::New() const {
  return new ProverState;
}

void ProverState::Clear() {
  round_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ProverState::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:yosysZKP.ProverState)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .yosysZKP.ProverSecret round = 1;
      case 1: {
        if (tag == 10) {
         parse_round:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_round()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_round;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:yosysZKP.ProverState)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:yosysZKP.ProverState)
  return false;
#undef DO_
}

void ProverState::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:yosysZKP.ProverState)
  // repeated .yosysZKP.ProverSecret round = 1;
  for (int i = 0; i < this->round_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->round(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:yosysZKP.ProverState)
}

::google::protobuf::uint8* ProverState::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:yosysZKP.ProverState)
  // repeated .yosysZKP.ProverSecret round = 1;
  for (int i = 0; i < this->round_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->round(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:yosysZKP.ProverState)
  return target;
}

int ProverState::ByteSize() const {
  int total_size = 0;

  // repeated .yosysZKP.ProverSecret round = 1;
  total_size += 1 * this->round_size();
  for (int i = 0; i < this->round_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->round(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ProverState::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ProverState* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ProverState*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ProverState::MergeFrom(const ProverState& from) {
  GOOGLE_CHECK_NE(&from, this);
  round_.MergeFrom(from.round_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ProverState::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ProverState::CopyFrom(const ProverState& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ProverState::IsInitialized() const {

  if (!::google::protobuf::internal::AllAreInitialized(this->round())) return false;
  return true;
}

void ProverState::Swap(ProverState* other) {
  if (other != this) {
    round_.Swap(&other->round_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ProverState::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ProverState_descriptor_;
  metadata.reflection = ProverState_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int RevealRequest::kScramblingFieldNumber;
#endif  // !_MSC_VER

RevealRequest::RevealRequest()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:yosysZKP.RevealRequest)
}

void RevealRequest::InitAsDefaultInstance() {
}

RevealRequest::RevealRequest(const RevealRequest& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:yosysZKP.RevealRequest)
}

void RevealRequest::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RevealRequest::~RevealRequest() {
  // @@protoc_insertion_point(destructor:yosysZKP.RevealRequest)
  SharedDtor();
}

void RevealRequest::SharedDtor() {
  if (this != default_instance_) {
  }
}

void RevealRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* RevealRequest::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return RevealRequest_descriptor_;
}

const RevealRequest& RevealRequest::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();
  return *default_instance_;
}

RevealRequest* RevealRequest::default_instance_ = NULL;

RevealRequest* RevealRequest::New() const {
  return new RevealRequest;
}

void RevealRequest::Clear() {
  scrambling_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool RevealRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:yosysZKP.RevealRequest)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated bool scrambling = 1;
      case 1: {
        if (tag == 8) {
         parse_scrambling:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 1, 8, input, this->mutable_scrambling())));
        } else if (tag == 10) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, this->mutable_scrambling())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(8)) goto parse_scrambling;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:yosysZKP.RevealRequest)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:yosysZKP.RevealRequest)
  return false;
#undef DO_
}

void RevealRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:yosysZKP.RevealRequest)
  // repeated bool scrambling = 1;
  for (int i = 0; i < this->scrambling_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(
      1, this->scrambling(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:yosysZKP.RevealRequest)
}

::google::protobuf::uint8* RevealRequest::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:yosysZKP.RevealRequest)
  // repeated bool scrambling = 1;
  for (int i = 0; i < this->scrambling_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteBoolToArray(1, this->scrambling(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:yosysZKP.RevealRequest)
  return target;
}

int RevealRequest::ByteSize() const {
  int total_size = 0;

  // repeated bool scrambling = 1;
  {
    int data_size = 0;
    data_size = 1 * this->scrambling_size();
    total_size += 1 * this->scrambling_size() + data_size;
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RevealRequest::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const RevealRequest* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const RevealRequest*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void RevealRequest::MergeFrom(const RevealRequest& from) {
  GOOGLE_CHECK_NE(&from, this);
  scrambling_.MergeFrom(from.scrambling_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void RevealRequest::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void RevealRequest::CopyFrom(const RevealRequest& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RevealRequest::IsInitialized() const {

  return true;
}

void RevealRequest::Swap(RevealRequest* other) {
  if (other != this) {
    scrambling_.Swap(&other->scrambling_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata RevealRequest::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = RevealRequest_descriptor_;
  metadata.reflection = RevealRequest_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ProveeState::kOutputFieldNumber;
const int ProveeState::kSecurityParamFieldNumber;
const int ProveeState::kConfidenceFieldNumber;
const int ProveeState::kCommitmentFieldNumber;
const int ProveeState::kRequestFieldNumber;
#endif  // !_MSC_VER

ProveeState::ProveeState()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:yosysZKP.ProveeState)
}

void ProveeState::InitAsDefaultInstance() {
  commitment_ = const_cast< ::yosysZKP::Commitments*>(&::yosysZKP::Commitments::default_instance());
  request_ = const_cast< ::yosysZKP::RevealRequest*>(&::yosysZKP::RevealRequest::default_instance());
}

ProveeState::ProveeState(const ProveeState& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:yosysZKP.ProveeState)
}

void ProveeState::SharedCtor() {
  _cached_size_ = 0;
  security_param_ = 0;
  confidence_ = 0;
  commitment_ = NULL;
  request_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ProveeState::~ProveeState() {
  // @@protoc_insertion_point(destructor:yosysZKP.ProveeState)
  SharedDtor();
}

void ProveeState::SharedDtor() {
  if (this != default_instance_) {
    delete commitment_;
    delete request_;
  }
}

void ProveeState::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ProveeState::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ProveeState_descriptor_;
}

const ProveeState& ProveeState::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();
  return *default_instance_;
}

ProveeState* ProveeState::default_instance_ = NULL;

ProveeState* ProveeState::New() const {
  return new ProveeState;
}

void ProveeState::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<ProveeState*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 30) {
    ZR_(security_param_, confidence_);
    if (has_commitment()) {
      if (commitment_ != NULL) commitment_->::yosysZKP::Commitments::Clear();
    }
    if (has_request()) {
      if (request_ != NULL) request_->::yosysZKP::RevealRequest::Clear();
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  output_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ProveeState::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:yosysZKP.ProveeState)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated bool output = 1;
      case 1: {
        if (tag == 8) {
         parse_output:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 1, 8, input, this->mutable_output())));
        } else if (tag == 10) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, this->mutable_output())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(8)) goto parse_output;
        if (input->ExpectTag(16)) goto parse_security_param;
        break;
      }

      // required int32 security_param = 2;
      case 2: {
        if (tag == 16) {
         parse_security_param:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &security_param_)));
          set_has_security_param();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_confidence;
        break;
      }

      // required int32 confidence = 3;
      case 3: {
        if (tag == 24) {
         parse_confidence:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &confidence_)));
          set_has_confidence();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_commitment;
        break;
      }

      // required .yosysZKP.Commitments commitment = 4;
      case 4: {
        if (tag == 34) {
         parse_commitment:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_commitment()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_request;
        break;
      }

      // required .yosysZKP.RevealRequest request = 5;
      case 5: {
        if (tag == 42) {
         parse_request:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_request()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:yosysZKP.ProveeState)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:yosysZKP.ProveeState)
  return false;
#undef DO_
}

void ProveeState::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:yosysZKP.ProveeState)
  // repeated bool output = 1;
  for (int i = 0; i < this->output_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(
      1, this->output(i), output);
  }

  // required int32 security_param = 2;
  if (has_security_param()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->security_param(), output);
  }

  // required int32 confidence = 3;
  if (has_confidence()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->confidence(), output);
  }

  // required .yosysZKP.Commitments commitment = 4;
  if (has_commitment()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->commitment(), output);
  }

  // required .yosysZKP.RevealRequest request = 5;
  if (has_request()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, this->request(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:yosysZKP.ProveeState)
}

::google::protobuf::uint8* ProveeState::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:yosysZKP.ProveeState)
  // repeated bool output = 1;
  for (int i = 0; i < this->output_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteBoolToArray(1, this->output(i), target);
  }

  // required int32 security_param = 2;
  if (has_security_param()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->security_param(), target);
  }

  // required int32 confidence = 3;
  if (has_confidence()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->confidence(), target);
  }

  // required .yosysZKP.Commitments commitment = 4;
  if (has_commitment()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->commitment(), target);
  }

  // required .yosysZKP.RevealRequest request = 5;
  if (has_request()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        5, this->request(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:yosysZKP.ProveeState)
  return target;
}

int ProveeState::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    // required int32 security_param = 2;
    if (has_security_param()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->security_param());
    }

    // required int32 confidence = 3;
    if (has_confidence()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->confidence());
    }

    // required .yosysZKP.Commitments commitment = 4;
    if (has_commitment()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->commitment());
    }

    // required .yosysZKP.RevealRequest request = 5;
    if (has_request()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->request());
    }

  }
  // repeated bool output = 1;
  {
    int data_size = 0;
    data_size = 1 * this->output_size();
    total_size += 1 * this->output_size() + data_size;
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ProveeState::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ProveeState* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ProveeState*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ProveeState::MergeFrom(const ProveeState& from) {
  GOOGLE_CHECK_NE(&from, this);
  output_.MergeFrom(from.output_);
  if (from._has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (from.has_security_param()) {
      set_security_param(from.security_param());
    }
    if (from.has_confidence()) {
      set_confidence(from.confidence());
    }
    if (from.has_commitment()) {
      mutable_commitment()->::yosysZKP::Commitments::MergeFrom(from.commitment());
    }
    if (from.has_request()) {
      mutable_request()->::yosysZKP::RevealRequest::MergeFrom(from.request());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ProveeState::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ProveeState::CopyFrom(const ProveeState& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ProveeState::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000001e) != 0x0000001e) return false;

  return true;
}

void ProveeState::Swap(ProveeState* other) {
  if (other != this) {
    output_.Swap(&other->output_);
    std::swap(security_param_, other->security_param_);
    std::swap(confidence_, other->confidence_);
    std::swap(commitment_, other->commitment_);
    std::swap(request_, other->request_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ProveeState::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ProveeState_descriptor_;
  metadata.reflection = ProveeState_reflection_;
  return metadata;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace yosysZKP

// @@protoc_insertion_point(global_scope)
